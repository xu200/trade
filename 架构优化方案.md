# ğŸ—ï¸ æ¶æ„ä¼˜åŒ–æ–¹æ¡ˆ - åç«¯ä¸­å¿ƒåŒ–è®¾è®¡

## ğŸ“Œ é—®é¢˜è¯´æ˜

åŸè®¾è®¡ä¸­å‰ç«¯ç›´æ¥è°ƒç”¨æ™ºèƒ½åˆçº¦ï¼Œå¯¼è‡´åç«¯ä½œç”¨æœ‰é™ã€‚ä¼˜åŒ–åé‡‡ç”¨**åç«¯ä¸­å¿ƒåŒ–æ¶æ„**ï¼Œå‰ç«¯é€šè¿‡åç«¯APIæ“ä½œï¼Œåç«¯è´Ÿè´£ä¸åŒºå—é“¾äº¤äº’ã€‚

---

## ğŸ¯ ä¼˜åŒ–åçš„æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         å‰ç«¯ (React)                     â”‚
â”‚  - åªè´Ÿè´£å±•ç¤ºå’Œç”¨æˆ·äº¤äº’                   â”‚
â”‚  - é€šè¿‡ HTTP API ä¸åç«¯é€šä¿¡               â”‚
â”‚  - MetaMask ä»…ç”¨äºèº«ä»½éªŒè¯ï¼ˆç­¾åï¼‰         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ HTTP API (REST)
              â”‚ ä¸ç›´æ¥è°ƒç”¨åˆçº¦
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      åç«¯ (Node.js + Express)            â”‚
â”‚  âœ… ç»Ÿä¸€çš„ä¸šåŠ¡é€»è¾‘å¤„ç†                    â”‚
â”‚  âœ… æƒé™éªŒè¯å’Œå®¡è®¡                        â”‚
â”‚  âœ… ä¸æ™ºèƒ½åˆçº¦äº¤äº’ï¼ˆä»£ç†ï¼‰                 â”‚
â”‚  âœ… æ•°æ®ç¼“å­˜å’ŒæŸ¥è¯¢ä¼˜åŒ–                    â”‚
â”‚  âœ… äº¤æ˜“é˜Ÿåˆ—å’Œé‡è¯•æœºåˆ¶                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ Web3 RPC
              â”‚ åç«¯ç»Ÿä¸€ç®¡ç†ç§é’¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    æ™ºèƒ½åˆçº¦ (Solidity)                   â”‚
â”‚  - æ•°æ®å­˜å‚¨å’ŒéªŒè¯                        â”‚
â”‚  - ä¸å¯ç¯¡æ”¹çš„äº¤æ˜“è®°å½•                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”„ æ–°çš„äº¤äº’æµç¨‹

### æ–¹æ¡ˆä¸€ï¼šåç«¯æ‰˜ç®¡è´¦æˆ·ï¼ˆæ¨èç”¨äºä¼ä¸šå†…éƒ¨ç³»ç»Ÿï¼‰

```
ç”¨æˆ·æ“ä½œ â†’ å‰ç«¯ â†’ åç«¯API â†’ åç«¯éªŒè¯æƒé™ â†’ åç«¯ç”¨æ‰˜ç®¡è´¦æˆ·è°ƒç”¨åˆçº¦ â†’ è¿”å›ç»“æœ
```

**ä¼˜ç‚¹ï¼š**
- âœ… ç”¨æˆ·æ— éœ€æ”¯ä»˜Gasè´¹
- âœ… äº¤æ˜“é€Ÿåº¦å¿«
- âœ… ç”¨æˆ·ä½“éªŒå¥½
- âœ… ä¾¿äºæ‰¹é‡æ“ä½œ

**é€‚ç”¨åœºæ™¯ï¼š** ä¼ä¸šå†…éƒ¨ç³»ç»Ÿã€è”ç›Ÿé“¾

### æ–¹æ¡ˆäºŒï¼šæ··åˆæ¨¡å¼ï¼ˆæ¨èç”¨äºå…¬é“¾ï¼‰

```
ç”¨æˆ·æ“ä½œ â†’ å‰ç«¯ â†’ åç«¯API â†’ åç«¯å‡†å¤‡äº¤æ˜“æ•°æ® â†’ å‰ç«¯MetaMaskç­¾å â†’ åç«¯æäº¤äº¤æ˜“ â†’ è¿”å›ç»“æœ
```

**ä¼˜ç‚¹ï¼š**
- âœ… ç”¨æˆ·ä¿ç•™ç§é’¥æ§åˆ¶æƒ
- âœ… åç«¯ä»å¯åšä¸šåŠ¡é€»è¾‘æ§åˆ¶
- âœ… ç¬¦åˆå»ä¸­å¿ƒåŒ–ç†å¿µ
- âœ… å®‰å…¨æ€§é«˜

**é€‚ç”¨åœºæ™¯ï¼š** å…¬é“¾åº”ç”¨ã€éœ€è¦ç”¨æˆ·è‡ªä¸»æ§åˆ¶èµ„äº§

---

## ğŸ“‹ åç«¯çš„æ ¸å¿ƒèŒè´£ï¼ˆé‡æ–°å®šä¹‰ï¼‰

### 1. èº«ä»½è®¤è¯å’Œæƒé™ç®¡ç† ğŸ”

```javascript
// ç”¨æˆ·ç™»å½•ï¼ˆé€šè¿‡ MetaMask ç­¾åéªŒè¯ï¼‰
POST /api/auth/login
{
  "address": "0x...",
  "signature": "ç­¾å",
  "message": "ç™»å½•æ¶ˆæ¯"
}

// åç«¯éªŒè¯ç­¾å
const recoveredAddress = ethers.verifyMessage(message, signature);
if (recoveredAddress === address) {
  // ç”Ÿæˆ JWT Token
  const token = jwt.sign({ address, role }, SECRET);
  return { token };
}
```

**åç«¯æ§åˆ¶ï¼š**
- âœ… åªæœ‰æ ¸å¿ƒä¼ä¸šå¯ä»¥åˆ›å»ºåº”æ”¶è´¦æ¬¾
- âœ… åªæœ‰ä¾›åº”å•†å¯ä»¥ç¡®è®¤è‡ªå·±çš„åº”æ”¶è´¦æ¬¾
- âœ… åªæœ‰é‡‘èæœºæ„å¯ä»¥å®¡æ‰¹èèµ„

### 2. ä¸šåŠ¡é€»è¾‘å±‚ ğŸ§ 

```javascript
// åˆ›å»ºåº”æ”¶è´¦æ¬¾ï¼ˆåç«¯å¤„ç†ï¼‰
POST /api/receivables/create
Headers: Authorization: Bearer <token>
{
  "supplier": "0x...",
  "amount": "100",
  "dueTime": "2025-12-31",
  "description": "...",
  "contractNumber": "CONTRACT-001"
}

// åç«¯å¤„ç†æµç¨‹ï¼š
1. éªŒè¯ JWT Token
2. æ£€æŸ¥ç”¨æˆ·è§’è‰²ï¼ˆå¿…é¡»æ˜¯æ ¸å¿ƒä¼ä¸šï¼‰
3. éªŒè¯ä¾›åº”å•†åœ°å€æ˜¯å¦å·²æ³¨å†Œ
4. æ£€æŸ¥åˆåŒç¼–å·æ˜¯å¦é‡å¤
5. éªŒè¯é‡‘é¢å’Œæ—¶é—´çš„åˆç†æ€§
6. è°ƒç”¨æ™ºèƒ½åˆçº¦åˆ›å»ºåº”æ”¶è´¦æ¬¾
7. ä¿å­˜åˆ°æ•°æ®åº“
8. å‘é€é€šçŸ¥ç»™ä¾›åº”å•†
9. è¿”å›ç»“æœ
```

### 3. æ•°æ®æŸ¥è¯¢ä¼˜åŒ– ğŸ“Š

```javascript
// å‰ç«¯æŸ¥è¯¢åº”æ”¶è´¦æ¬¾åˆ—è¡¨
GET /api/receivables?page=1&limit=10&status=confirmed

// åç«¯ç›´æ¥ä»æ•°æ®åº“æŸ¥è¯¢ï¼ˆå¿«é€Ÿï¼‰
// è€Œä¸æ˜¯æ¯æ¬¡éƒ½æŸ¥é“¾ä¸Šæ•°æ®ï¼ˆæ…¢ï¼‰
SELECT * FROM receivables_index 
WHERE owner_address = ? 
AND confirmed = true
ORDER BY created_at DESC
LIMIT 10 OFFSET 0;

// è¿”å›ç»“æœåŒ…å«ï¼š
{
  "total": 100,
  "items": [...],
  "stats": {
    "totalAmount": "10000",
    "confirmedCount": 50
  }
}
```

### 4. äº¤æ˜“ç®¡ç†å’Œç›‘æ§ ğŸ“¡

```javascript
// åç«¯ç®¡ç†äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ
class TransactionManager {
  async submitTransaction(type, data, userAddress) {
    // 1. åˆ›å»ºäº¤æ˜“è®°å½•
    const tx = await TransactionHistory.create({
      from_address: userAddress,
      tx_type: type,
      status: 'pending',
      data: JSON.stringify(data)
    });

    try {
      // 2. è°ƒç”¨æ™ºèƒ½åˆçº¦
      const receipt = await contractService.createReceivable(...data);
      
      // 3. æ›´æ–°äº¤æ˜“çŠ¶æ€
      await tx.update({
        tx_hash: receipt.hash,
        status: 'success',
        block_number: receipt.blockNumber
      });

      // 4. åŒæ­¥æ•°æ®åˆ°æ•°æ®åº“
      await this.syncReceivable(receipt.events.ReceivableCreated.id);

      // 5. å‘é€é€šçŸ¥
      await notificationService.send(data.supplier, 'æ‚¨æœ‰æ–°çš„åº”æ”¶è´¦æ¬¾');

      return receipt;
    } catch (error) {
      // 6. è®°å½•å¤±è´¥åŸå› 
      await tx.update({
        status: 'failed',
        error_message: error.message
      });
      throw error;
    }
  }
}
```

### 5. é«˜çº§åŠŸèƒ½ ğŸš€

```javascript
// æ‰¹é‡æ“ä½œï¼ˆå‰ç«¯æ— æ³•åšåˆ°ï¼‰
POST /api/receivables/batch-confirm
{
  "ids": [1, 2, 3, 4, 5]
}

// åç«¯æ‰¹é‡å¤„ç†
for (const id of ids) {
  await contractService.confirmReceivable(id);
}

// å®šæ—¶ä»»åŠ¡ï¼ˆå‰ç«¯æ— æ³•åšåˆ°ï¼‰
// æ¯å¤©æ£€æŸ¥åˆ°æœŸçš„åº”æ”¶è´¦æ¬¾
cron.schedule('0 0 * * *', async () => {
  const expired = await ReceivableIndex.findAll({
    where: {
      due_time: { [Op.lt]: new Date() },
      settled: false
    }
  });

  // å‘é€æé†’é€šçŸ¥
  for (const r of expired) {
    await notificationService.send(r.issuer_address, 'åº”æ”¶è´¦æ¬¾å·²åˆ°æœŸ');
  }
});

// æ•°æ®ç»Ÿè®¡å’ŒæŠ¥è¡¨ï¼ˆå‰ç«¯æ— æ³•é«˜æ•ˆå®ç°ï¼‰
GET /api/stats/dashboard

// åç«¯å¤æ‚æŸ¥è¯¢
SELECT 
  DATE(create_time) as date,
  COUNT(*) as count,
  SUM(amount) as total_amount
FROM receivables_index
WHERE issuer_address = ?
GROUP BY DATE(create_time)
ORDER BY date DESC
LIMIT 30;
```

---

## ğŸ”§ ä¼˜åŒ–åçš„å‰ç«¯å®ç°

### 1. å‰ç«¯æœåŠ¡å±‚ï¼ˆä¸å†ç›´æ¥è°ƒç”¨åˆçº¦ï¼‰

```javascript
// services/apiService.js
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_URL;

class ApiService {
  constructor() {
    this.client = axios.create({
      baseURL: API_BASE_URL,
      timeout: 30000
    });

    // è¯·æ±‚æ‹¦æˆªå™¨ï¼šæ·»åŠ  Token
    this.client.interceptors.request.use(config => {
      const token = localStorage.getItem('token');
      if (token) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });
  }

  // ========== è®¤è¯ç›¸å…³ ==========
  
  async login(address, signature, message) {
    const { data } = await this.client.post('/api/auth/login', {
      address,
      signature,
      message
    });
    localStorage.setItem('token', data.token);
    return data;
  }

  async register(address, role, companyName) {
    const { data } = await this.client.post('/api/auth/register', {
      address,
      role,
      companyName
    });
    return data;
  }

  // ========== åº”æ”¶è´¦æ¬¾ç›¸å…³ ==========
  
  async getReceivables(params) {
    const { data } = await this.client.get('/api/receivables', { params });
    return data;
  }

  async getReceivableDetail(id) {
    const { data } = await this.client.get(`/api/receivables/${id}`);
    return data;
  }

  async createReceivable(receivableData) {
    const { data } = await this.client.post('/api/receivables', receivableData);
    return data;
  }

  async confirmReceivable(id) {
    const { data } = await this.client.post(`/api/receivables/${id}/confirm`);
    return data;
  }

  async transferReceivable(id, newOwner) {
    const { data } = await this.client.post(`/api/receivables/${id}/transfer`, {
      newOwner
    });
    return data;
  }

  // ========== èèµ„ç›¸å…³ ==========
  
  async applyForFinance(applicationData) {
    const { data } = await this.client.post('/api/finance/apply', applicationData);
    return data;
  }

  async approveFinance(appId, approved) {
    const { data } = await this.client.post(`/api/finance/${appId}/approve`, {
      approved
    });
    return data;
  }

  async getFinanceApplications(params) {
    const { data } = await this.client.get('/api/finance/applications', { params });
    return data;
  }

  // ========== ç»Ÿè®¡ç›¸å…³ ==========
  
  async getDashboardStats() {
    const { data } = await this.client.get('/api/stats/dashboard');
    return data;
  }

  async getTransactionHistory(params) {
    const { data } = await this.client.get('/api/transactions', { params });
    return data;
  }
}

export default new ApiService();
```

### 2. å‰ç«¯è®¤è¯æµç¨‹ï¼ˆä½¿ç”¨ MetaMask ç­¾åï¼‰

```javascript
// services/authService.js
import { ethers } from 'ethers';
import apiService from './apiService';

class AuthService {
  // ç™»å½•ï¼ˆé€šè¿‡ç­¾åéªŒè¯èº«ä»½ï¼‰
  async login() {
    if (!window.ethereum) {
      throw new Error('è¯·å®‰è£… MetaMask');
    }

    // 1. è¿æ¥é’±åŒ…
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const address = await signer.getAddress();

    // 2. ç”Ÿæˆç™»å½•æ¶ˆæ¯
    const message = `ç™»å½•åˆ°ä¾›åº”é“¾é‡‘èç³»ç»Ÿ\nåœ°å€: ${address}\næ—¶é—´: ${new Date().toISOString()}`;

    // 3. è¯·æ±‚ç”¨æˆ·ç­¾å
    const signature = await signer.signMessage(message);

    // 4. å‘é€åˆ°åç«¯éªŒè¯
    const result = await apiService.login(address, signature, message);

    return {
      address,
      token: result.token,
      userInfo: result.userInfo
    };
  }

  // æ³¨å†Œ
  async register(role, companyName) {
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const address = await signer.getAddress();

    const result = await apiService.register(address, role, companyName);
    return result;
  }

  // ç™»å‡º
  logout() {
    localStorage.removeItem('token');
  }

  // æ£€æŸ¥æ˜¯å¦ç™»å½•
  isAuthenticated() {
    return !!localStorage.getItem('token');
  }
}

export default new AuthService();
```

### 3. å‰ç«¯çŠ¶æ€ç®¡ç†ï¼ˆä½¿ç”¨åç«¯APIï¼‰

```javascript
// store/receivableStore.js
import { create } from 'zustand';
import apiService from '../services/apiService';

export const useReceivableStore = create((set, get) => ({
  receivables: [],
  currentReceivable: null,
  isLoading: false,
  stats: null,

  // è·å–åº”æ”¶è´¦æ¬¾åˆ—è¡¨ï¼ˆä»åç«¯APIï¼‰
  fetchReceivables: async (params) => {
    set({ isLoading: true });
    try {
      const result = await apiService.getReceivables(params);
      set({ 
        receivables: result.data.items,
        isLoading: false 
      });
      return result.data;
    } catch (error) {
      console.error('è·å–åº”æ”¶è´¦æ¬¾å¤±è´¥:', error);
      set({ isLoading: false });
      throw error;
    }
  },

  // åˆ›å»ºåº”æ”¶è´¦æ¬¾ï¼ˆé€šè¿‡åç«¯APIï¼‰
  createReceivable: async (data) => {
    try {
      const result = await apiService.createReceivable(data);
      // åˆ·æ–°åˆ—è¡¨
      await get().fetchReceivables();
      return result;
    } catch (error) {
      console.error('åˆ›å»ºåº”æ”¶è´¦æ¬¾å¤±è´¥:', error);
      throw error;
    }
  },

  // ç¡®è®¤åº”æ”¶è´¦æ¬¾ï¼ˆé€šè¿‡åç«¯APIï¼‰
  confirmReceivable: async (id) => {
    try {
      const result = await apiService.confirmReceivable(id);
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      const { receivables } = get();
      const updated = receivables.map(r => 
        r.id === id ? { ...r, confirmed: true } : r
      );
      set({ receivables: updated });
      return result;
    } catch (error) {
      console.error('ç¡®è®¤åº”æ”¶è´¦æ¬¾å¤±è´¥:', error);
      throw error;
    }
  },

  // è·å–ç»Ÿè®¡æ•°æ®ï¼ˆä»åç«¯APIï¼‰
  fetchStats: async () => {
    try {
      const stats = await apiService.getDashboardStats();
      set({ stats });
      return stats;
    } catch (error) {
      console.error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
      throw error;
    }
  }
}));
```

---

## ğŸ”§ ä¼˜åŒ–åçš„åç«¯å®ç°

### 1. è®¤è¯ä¸­é—´ä»¶

```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken');
const { ethers } = require('ethers');

// JWT è®¤è¯ä¸­é—´ä»¶
exports.authenticate = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: 'æœªæä¾›è®¤è¯ä»¤ç‰Œ'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: 'è®¤è¯å¤±è´¥'
    });
  }
};

// è§’è‰²éªŒè¯ä¸­é—´ä»¶
exports.requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'æƒé™ä¸è¶³'
      });
    }
    next();
  };
};
```

### 2. è®¤è¯æ§åˆ¶å™¨

```javascript
// controllers/authController.js
const jwt = require('jsonwebtoken');
const { ethers } = require('ethers');
const User = require('../models/User');
const contractService = require('../services/contractService');

class AuthController {
  // ç™»å½•
  async login(req, res, next) {
    try {
      const { address, signature, message } = req.body;

      // 1. éªŒè¯ç­¾å
      const recoveredAddress = ethers.verifyMessage(message, signature);
      
      if (recoveredAddress.toLowerCase() !== address.toLowerCase()) {
        return res.status(401).json({
          success: false,
          message: 'ç­¾åéªŒè¯å¤±è´¥'
        });
      }

      // 2. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
      let user = await User.findOne({ where: { wallet_address: address } });
      
      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'ç”¨æˆ·æœªæ³¨å†Œ'
        });
      }

      // 3. ä»é“¾ä¸Šè·å–ç”¨æˆ·è§’è‰²
      const roleOnChain = await contractService.getUserRole(address);
      
      // 4. ç”Ÿæˆ JWT Token
      const token = jwt.sign(
        {
          address: user.wallet_address,
          role: user.role,
          userId: user.id
        },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      res.json({
        success: true,
        data: {
          token,
          userInfo: {
            address: user.wallet_address,
            role: user.role,
            companyName: user.company_name,
            roleOnChain: Number(roleOnChain)
          }
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // æ³¨å†Œ
  async register(req, res, next) {
    try {
      const { address, role, companyName, contactPerson, contactEmail } = req.body;

      // 1. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
      const existing = await User.findOne({ where: { wallet_address: address } });
      
      if (existing) {
        return res.status(400).json({
          success: false,
          message: 'ç”¨æˆ·å·²æ³¨å†Œ'
        });
      }

      // 2. åœ¨é“¾ä¸Šæ³¨å†Œç”¨æˆ·
      const roleMap = {
        'core_company': 1,
        'supplier': 2,
        'financier': 3
      };

      await contractService.registerUser(roleMap[role], companyName);

      // 3. ä¿å­˜åˆ°æ•°æ®åº“
      const user = await User.create({
        wallet_address: address,
        role: role,
        company_name: companyName,
        contact_person: contactPerson,
        contact_email: contactEmail
      });

      res.json({
        success: true,
        data: {
          userId: user.id,
          message: 'æ³¨å†ŒæˆåŠŸ'
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
  async getCurrentUser(req, res, next) {
    try {
      const user = await User.findOne({
        where: { wallet_address: req.user.address }
      });

      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new AuthController();
```

### 3. åº”æ”¶è´¦æ¬¾æ§åˆ¶å™¨ï¼ˆå®Œæ•´ç‰ˆï¼‰

```javascript
// controllers/receivableController.js
const contractService = require('../services/contractService');
const ReceivableIndex = require('../models/ReceivableIndex');
const TransactionHistory = require('../models/TransactionHistory');
const notificationService = require('../services/notificationService');
const { ethers } = require('ethers');

class ReceivableController {
  // åˆ›å»ºåº”æ”¶è´¦æ¬¾
  async create(req, res, next) {
    try {
      const { supplier, amount, dueTime, description, contractNumber } = req.body;
      const issuerAddress = req.user.address;

      // 1. æƒé™æ£€æŸ¥
      if (req.user.role !== 'core_company') {
        return res.status(403).json({
          success: false,
          message: 'åªæœ‰æ ¸å¿ƒä¼ä¸šå¯ä»¥åˆ›å»ºåº”æ”¶è´¦æ¬¾'
        });
      }

      // 2. å‚æ•°éªŒè¯
      if (!ethers.isAddress(supplier)) {
        return res.status(400).json({
          success: false,
          message: 'æ— æ•ˆçš„ä¾›åº”å•†åœ°å€'
        });
      }

      // 3. æ£€æŸ¥åˆåŒç¼–å·æ˜¯å¦é‡å¤
      const existing = await ReceivableIndex.findOne({
        where: { contract_number: contractNumber }
      });

      if (existing) {
        return res.status(400).json({
          success: false,
          message: 'åˆåŒç¼–å·å·²å­˜åœ¨'
        });
      }

      // 4. è°ƒç”¨æ™ºèƒ½åˆçº¦
      const receipt = await contractService.createReceivable(
        supplier,
        amount,
        dueTime,
        description,
        contractNumber
      );

      // 5. ä»äº‹ä»¶ä¸­è·å–åº”æ”¶è´¦æ¬¾ID
      const event = receipt.logs.find(log => 
        log.fragment && log.fragment.name === 'ReceivableCreated'
      );
      const receivableId = event.args[0];

      // 6. ä¿å­˜åˆ°æ•°æ®åº“
      const receivable = await ReceivableIndex.create({
        receivable_id: Number(receivableId),
        issuer_address: issuerAddress,
        owner_address: supplier,
        supplier_address: supplier,
        amount: ethers.parseEther(amount.toString()).toString(),
        contract_number: contractNumber,
        description: description,
        create_time: new Date(),
        due_time: new Date(dueTime),
        confirmed: false,
        financed: false,
        settled: false,
        tx_hash: receipt.hash,
        block_number: receipt.blockNumber
      });

      // 7. è®°å½•äº¤æ˜“å†å²
      await TransactionHistory.create({
        tx_hash: receipt.hash,
        from_address: issuerAddress,
        to_address: process.env.CONTRACT_ADDRESS,
        tx_type: 'create',
        related_id: Number(receivableId),
        block_number: receipt.blockNumber,
        gas_used: receipt.gasUsed.toString(),
        timestamp: new Date(),
        status: 'success'
      });

      // 8. å‘é€é€šçŸ¥ç»™ä¾›åº”å•†
      await notificationService.send(supplier, {
        type: 'receivable_created',
        title: 'æ–°çš„åº”æ”¶è´¦æ¬¾',
        message: `æ‚¨æ”¶åˆ°ä¸€ç¬”é‡‘é¢ä¸º ${amount} ETH çš„åº”æ”¶è´¦æ¬¾`,
        receivableId: Number(receivableId)
      });

      res.json({
        success: true,
        data: {
          receivableId: Number(receivableId),
          txHash: receipt.hash,
          receivable: receivable
        },
        message: 'åº”æ”¶è´¦æ¬¾åˆ›å»ºæˆåŠŸ'
      });
    } catch (error) {
      console.error('åˆ›å»ºåº”æ”¶è´¦æ¬¾å¤±è´¥:', error);
      next(error);
    }
  }

  // ç¡®è®¤åº”æ”¶è´¦æ¬¾
  async confirm(req, res, next) {
    try {
      const { id } = req.params;
      const userAddress = req.user.address;

      // 1. ä»æ•°æ®åº“è·å–åº”æ”¶è´¦æ¬¾ä¿¡æ¯
      const receivable = await ReceivableIndex.findOne({
        where: { receivable_id: id }
      });

      if (!receivable) {
        return res.status(404).json({
          success: false,
          message: 'åº”æ”¶è´¦æ¬¾ä¸å­˜åœ¨'
        });
      }

      // 2. æƒé™æ£€æŸ¥
      if (receivable.owner_address.toLowerCase() !== userAddress.toLowerCase()) {
        return res.status(403).json({
          success: false,
          message: 'æ‚¨ä¸æ˜¯è¯¥åº”æ”¶è´¦æ¬¾çš„æŒæœ‰äºº'
        });
      }

      if (receivable.confirmed) {
        return res.status(400).json({
          success: false,
          message: 'åº”æ”¶è´¦æ¬¾å·²ç¡®è®¤'
        });
      }

      // 3. è°ƒç”¨æ™ºèƒ½åˆçº¦
      const receipt = await contractService.confirmReceivable(id);

      // 4. æ›´æ–°æ•°æ®åº“
      await receivable.update({
        confirmed: true,
        tx_hash: receipt.hash
      });

      // 5. è®°å½•äº¤æ˜“å†å²
      await TransactionHistory.create({
        tx_hash: receipt.hash,
        from_address: userAddress,
        to_address: process.env.CONTRACT_ADDRESS,
        tx_type: 'confirm',
        related_id: id,
        block_number: receipt.blockNumber,
        gas_used: receipt.gasUsed.toString(),
        timestamp: new Date(),
        status: 'success'
      });

      // 6. é€šçŸ¥å‘è¡Œæ–¹
      await notificationService.send(receivable.issuer_address, {
        type: 'receivable_confirmed',
        title: 'åº”æ”¶è´¦æ¬¾å·²ç¡®è®¤',
        message: `åº”æ”¶è´¦æ¬¾ #${id} å·²è¢«ä¾›åº”å•†ç¡®è®¤`,
        receivableId: id
      });

      res.json({
        success: true,
        data: {
          receivableId: id,
          txHash: receipt.hash
        },
        message: 'åº”æ”¶è´¦æ¬¾ç¡®è®¤æˆåŠŸ'
      });
    } catch (error) {
      console.error('ç¡®è®¤åº”æ”¶è´¦æ¬¾å¤±è´¥:', error);
      next(error);
    }
  }

  // è·å–åº”æ”¶è´¦æ¬¾åˆ—è¡¨
  async list(req, res, next) {
    try {
      const { 
        page = 1, 
        limit = 10, 
        status, 
        owner, 
        issuer,
        search 
      } = req.query;

      const where = {};

      // æ ¹æ®å½“å‰ç”¨æˆ·è§’è‰²è¿‡æ»¤
      if (req.user.role === 'supplier') {
        where.owner_address = req.user.address;
      } else if (req.user.role === 'core_company') {
        where.issuer_address = req.user.address;
      }

      // çŠ¶æ€è¿‡æ»¤
      if (status === 'confirmed') where.confirmed = true;
      if (status === 'unconfirmed') where.confirmed = false;
      if (status === 'financed') where.financed = true;
      if (status === 'settled') where.settled = true;

      // åœ°å€è¿‡æ»¤
      if (owner) where.owner_address = owner;
      if (issuer) where.issuer_address = issuer;

      // æœç´¢
      if (search) {
        where[Op.or] = [
          { contract_number: { [Op.like]: `%${search}%` } },
          { description: { [Op.like]: `%${search}%` } }
        ];
      }

      const offset = (page - 1) * limit;

      const { count, rows } = await ReceivableIndex.findAndCountAll({
        where,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [['created_at', 'DESC']]
      });

      res.json({
        success: true,
        data: {
          total: count,
          page: parseInt(page),
          pageSize: parseInt(limit),
          totalPages: Math.ceil(count / limit),
          items: rows
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // è·å–åº”æ”¶è´¦æ¬¾è¯¦æƒ…
  async detail(req, res, next) {
    try {
      const { id } = req.params;

      // ä»æ•°æ®åº“è·å–
      const receivable = await ReceivableIndex.findOne({
        where: { receivable_id: id }
      });

      if (!receivable) {
        return res.status(404).json({
          success: false,
          message: 'åº”æ”¶è´¦æ¬¾ä¸å­˜åœ¨'
        });
      }

      // è·å–ç›¸å…³äº¤æ˜“å†å²
      const transactions = await TransactionHistory.findAll({
        where: { related_id: id },
        order: [['timestamp', 'DESC']]
      });

      res.json({
        success: true,
        data: {
          receivable,
          transactions
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // è½¬è®©åº”æ”¶è´¦æ¬¾
  async transfer(req, res, next) {
    try {
      const { id } = req.params;
      const { newOwner } = req.body;
      const userAddress = req.user.address;

      // éªŒè¯å’Œæƒé™æ£€æŸ¥...
      // è°ƒç”¨åˆçº¦...
      // æ›´æ–°æ•°æ®åº“...
      // å‘é€é€šçŸ¥...

      res.json({
        success: true,
        message: 'è½¬è®©æˆåŠŸ'
      });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new ReceivableController();
```

### 4. åˆçº¦æœåŠ¡ï¼ˆåç«¯æ‰˜ç®¡è´¦æˆ·ï¼‰

```javascript
// services/contractService.js
const { ethers } = require('ethers');
const contractABI = require('../contracts/SupplyChainFinance.json');

class ContractService {
  constructor() {
    this.provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
    
    // åç«¯æ‰˜ç®¡è´¦æˆ·ï¼ˆä»ç¯å¢ƒå˜é‡è¯»å–ç§é’¥ï¼‰
    this.wallet = new ethers.Wallet(process.env.PRIVATE_KEY, this.provider);
    
    this.contract = new ethers.Contract(
      process.env.CONTRACT_ADDRESS,
      contractABI.abi,
      this.wallet  // ä½¿ç”¨åç«¯è´¦æˆ·ç­¾å
    );
  }

  // æ³¨å†Œç”¨æˆ·
  async registerUser(role, name) {
    const tx = await this.contract.registerUser(role, name);
    return await tx.wait();
  }

  // åˆ›å»ºåº”æ”¶è´¦æ¬¾
  async createReceivable(supplier, amount, dueTime, description, contractNumber) {
    const amountWei = ethers.parseEther(amount.toString());
    const dueTimestamp = Math.floor(new Date(dueTime).getTime() / 1000);

    const tx = await this.contract.createReceivable(
      supplier,
      amountWei,
      dueTimestamp,
      description,
      contractNumber
    );

    return await tx.wait();
  }

  // ç¡®è®¤åº”æ”¶è´¦æ¬¾
  async confirmReceivable(id) {
    const tx = await this.contract.confirmReceivable(id);
    return await tx.wait();
  }

  // è½¬è®©åº”æ”¶è´¦æ¬¾
  async transferReceivable(id, newOwner) {
    const tx = await this.contract.transferReceivable(id, newOwner);
    return await tx.wait();
  }

  // è·å–ç”¨æˆ·è§’è‰²ï¼ˆåªè¯»ï¼‰
  async getUserRole(address) {
    return await this.contract.getUserRole(address);
  }

  // è·å–åº”æ”¶è´¦æ¬¾è¯¦æƒ…ï¼ˆåªè¯»ï¼‰
  async getReceivable(id) {
    return await this.contract.getReceivable(id);
  }
}

module.exports = new ContractService();
```

---

## ğŸ“Š ä¸¤ç§æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | æ–¹æ¡ˆä¸€ï¼šåç«¯æ‰˜ç®¡ | æ–¹æ¡ˆäºŒï¼šæ··åˆæ¨¡å¼ |
|------|----------------|----------------|
| **Gasè´¹ç”¨** | åç«¯æ‰¿æ‹… | ç”¨æˆ·æ‰¿æ‹… |
| **äº¤æ˜“é€Ÿåº¦** | å¿«ï¼ˆåç«¯ç›´æ¥æäº¤ï¼‰ | è¾ƒæ…¢ï¼ˆéœ€ç”¨æˆ·ç¡®è®¤ï¼‰ |
| **ç”¨æˆ·ä½“éªŒ** | å¥½ï¼ˆæ— éœ€MetaMaskç¡®è®¤ï¼‰ | ä¸€èˆ¬ï¼ˆéœ€å¤šæ¬¡ç¡®è®¤ï¼‰ |
| **å®‰å…¨æ€§** | ä¾èµ–åç«¯å®‰å…¨ | é«˜ï¼ˆç”¨æˆ·æ§åˆ¶ç§é’¥ï¼‰ |
| **å»ä¸­å¿ƒåŒ–** | å¼± | å¼º |
| **é€‚ç”¨åœºæ™¯** | ä¼ä¸šå†…éƒ¨ã€è”ç›Ÿé“¾ | å…¬é“¾ã€DeFi |
| **å¼€å‘å¤æ‚åº¦** | ä½ | ä¸­ |

---

## ğŸ¯ æ¨èæ–¹æ¡ˆ

### å¯¹äºä½ çš„é¡¹ç›®ï¼Œæˆ‘æ¨è**æ–¹æ¡ˆä¸€ï¼šåç«¯æ‰˜ç®¡è´¦æˆ·**

**ç†ç”±ï¼š**
1. âœ… è¿™æ˜¯ä¾›åº”é“¾é‡‘èç³»ç»Ÿï¼Œé€šå¸¸æ˜¯ä¼ä¸šå†…éƒ¨æˆ–è”ç›Ÿé“¾ä½¿ç”¨
2. âœ… ç”¨æˆ·æ— éœ€æ”¯ä»˜Gasè´¹ï¼Œä½“éªŒæ›´å¥½
3. âœ… åç«¯å¯ä»¥åšæ›´å¤šä¸šåŠ¡é€»è¾‘æ§åˆ¶
4. âœ… å¼€å‘å’Œç»´æŠ¤æ›´ç®€å•
5. âœ… ç¬¦åˆä¼ ç»Ÿé‡‘èç³»ç»Ÿçš„ä½¿ç”¨ä¹ æƒ¯

**MetaMask çš„ä½œç”¨ï¼š**
- ä»…ç”¨äºèº«ä»½éªŒè¯ï¼ˆç­¾åç™»å½•ï¼‰
- ä¸ç”¨äºäº¤æ˜“ç­¾å
- ç”¨æˆ·ä½“éªŒç±»ä¼¼ä¼ ç»ŸWebåº”ç”¨

---

## ğŸ“ æ€»ç»“

ä¼˜åŒ–åçš„æ¶æ„ä¸­ï¼Œ**åç«¯çœŸæ­£æˆä¸ºæ ¸å¿ƒ**ï¼š

1. **èº«ä»½è®¤è¯å’Œæƒé™ç®¡ç†** - åç«¯æ§åˆ¶è°èƒ½åšä»€ä¹ˆ
2. **ä¸šåŠ¡é€»è¾‘å¤„ç†** - åç«¯éªŒè¯æ•°æ®åˆç†æ€§
3. **ä¸åŒºå—é“¾äº¤äº’** - åç«¯ç»Ÿä¸€ç®¡ç†äº¤æ˜“
4. **æ•°æ®æŸ¥è¯¢ä¼˜åŒ–** - åç«¯ç¼“å­˜æå‡æ€§èƒ½
5. **é«˜çº§åŠŸèƒ½** - æ‰¹é‡æ“ä½œã€å®šæ—¶ä»»åŠ¡ã€ç»Ÿè®¡æŠ¥è¡¨

å‰ç«¯å˜å¾—æ›´ç®€å•ï¼š
- åªè´Ÿè´£UIå±•ç¤ºå’Œç”¨æˆ·äº¤äº’
- é€šè¿‡HTTP APIä¸åç«¯é€šä¿¡
- ä¸éœ€è¦ç†è§£åŒºå—é“¾ç»†èŠ‚

è¿™æ ·çš„æ¶æ„æ—¢ä¿ç•™äº†åŒºå—é“¾çš„ä¼˜åŠ¿ï¼ˆä¸å¯ç¯¡æ”¹ã€å¯è¿½æº¯ï¼‰ï¼Œåˆæä¾›äº†ä¼ ç»Ÿåº”ç”¨çš„ç”¨æˆ·ä½“éªŒï¼

