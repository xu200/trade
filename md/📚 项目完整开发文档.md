# 📚 区块链供应链金融系统 - 完整开发文档

> 作者：Xu200  
> 最后更新：2025-10-24

---

## 📖 目录

- [第一部分：项目概览](#第一部分项目概览)
- [第二部分：智能合约开发](#第二部分智能合约开发)
- [第三部分：后端开发](#第三部分后端开发)
- [第四部分：前端开发](#第四部分前端开发)
- [第五部分：部署与运维](#第五部分部署与运维)
- [第六部分：测试与调试](#第六部分测试与调试)

---

## 第一部分：项目概览

### 1.1 项目背景

供应链金融是解决中小企业融资难的重要手段。本项目利用区块链技术，打造一个透明、高效、可信的供应链金融平台。

#### 核心痛点

- **供应商**：账期长，资金压力大
- **金融机构**：信息不对称，风险高
- **核心企业**：供应商资金链断裂影响供应稳定

#### 解决方案

- **透明可信**：区块链记录所有交易，不可篡改
- **自动执行**：智能合约自动处理资金流转
- **降低成本**：减少中介环节和审核成本

### 1.2 系统角色

| 角色 | 职责 | 核心操作 |
|------|------|----------|
| **核心企业** | 大型企业，信用好 | 创建应收账款、到期结算 |
| **供应商** | 中小企业，提供货物/服务 | 确认应收账款、申请融资 |
| **金融机构** | 银行或金融公司 | 审批融资、提供资金 |

### 1.3 完整业务流程

```
[核心企业] 创建应收账款
    ↓ (锁定100 ETH到合约)
[供应商] 确认应收账款
    ↓ (MetaMask签名确认)
[供应商] 申请融资
    ↓ (申请90 ETH，利率10%)
[金融机构] 批准融资
    ↓ (转账90 ETH给供应商)
[核心企业] 到期结算
    ↓ (合约转账100 ETH给金融机构)
完成 ✅
```

### 1.4 资金流动

#### 时间线

| 时间点 | 事件 | 资金变化 | 各方状态 |
|--------|------|----------|----------|
| **T0** | 创建应收账款 | 核心企业锁定100 ETH到合约 | 核心企业：-100 ETH（锁定） |
| **T1** | 供应商确认 | 无 | 供应商：确权完成 |
| **T2** | 申请融资 | 无 | 等待审批 |
| **T3** | 批准融资 | 金融机构 → 90 ETH → 供应商 | 供应商：+90 ETH ✅<br>金融机构：-90 ETH |
| **T30** | 到期结算 | 合约 → 100 ETH → 金融机构 | 金融机构：+100 ETH ✅<br>核心企业：解锁 |

#### 各方收益

- **供应商**：
  - 成本：10 ETH（利息）
  - 收益：立即获得90 ETH现金流
  
- **金融机构**：
  - 投入：90 ETH
  - 收益：100 ETH（10 ETH利润，约11%收益）
  
- **核心企业**：
  - 成本：无（只是延期付款）
  - 收益：维护供应链稳定

### 1.5 技术架构

```
┌────────────────────────────────────────────────┐
│          前端层 (React + MetaMask)              │
│  ┌──────────────┐     ┌──────────────────┐    │
│  │  数据查询    │────→│    HTTP API      │    │
│  └──────────────┘     └──────────────────┘    │
│  ┌──────────────┐     ┌──────────────────┐    │
│  │  关键操作    │────→│   Web3 (直接)    │    │
│  └──────────────┘     └──────────────────┘    │
└────────┬───────────────────────┬───────────────┘
         │ REST API               │ JSON-RPC
         ↓                        ↓
┌─────────────────┐     ┌──────────────────────┐
│  后端层 (Express)│     │  智能合约 (Solidity) │
│  • 数据缓存     │←───→│  • 资金锁定/转账     │
│  • 事件监听     │ Web3│  • 权限控制          │
│  • JWT认证      │     │  • 状态管理          │
└────────┬────────┘     └──────────────────────┘
         │
         ↓
┌──────────────────┐
│  数据层 (MySQL)   │
│  • 用户表        │
│  • 应收账款索引   │
│  • 交易历史      │
└──────────────────┘
```

---

## 第二部分：智能合约开发

### 2.1 合约结构

#### 核心数据结构

```solidity
// 用户角色
enum UserRole {
    NONE,           // 0: 未注册
    CORE_COMPANY,   // 1: 核心企业
    SUPPLIER,       // 2: 供应商
    FINANCIER       // 3: 金融机构
}

// 应收账款
struct Receivable {
    address issuer;       // 发行方（核心企业）
    address owner;        // 当前持有人
    uint256 amount;       // 金额（Wei）
    uint256 dueTime;      // 到期时间
    bool confirmed;       // 是否已确认
    bool financed;        // 是否已融资
    bool settled;         // 是否已结算
}

// 融资申请
struct FinanceApplication {
    uint256 receivableId;  // 应收账款ID
    address applicant;     // 申请人
    address financier;     // 金融机构
    uint256 financeAmount; // 融资金额
    uint256 interestRate;  // 利率（基点，1000=10%）
    bool approved;         // 是否批准
    bool processed;        // 是否已处理
}
```

#### 关键函数

```solidity
// 1. 用户注册
function registerUser(UserRole _role, string memory _name) external

// 2. 创建应收账款（锁定ETH）
function createReceivable(
    address _supplier,
    uint256 _amount,
    uint256 _dueTime,
    string memory _description,
    string memory _contractNumber
) external payable onlyCoreCompany returns (uint256)

// 3. 供应商确认
function confirmReceivable(uint256 _id) external

// 4. 申请融资
function applyForFinance(
    uint256 _receivableId,
    address _financier,
    uint256 _financeAmount,
    uint256 _interestRate
) external onlySupplier returns (uint256)

// 5. 批准融资（转账ETH给供应商）
function approveFinanceApplication(uint256 _appId) 
    external payable onlyFinancier

// 6. 到期结算（转账给金融机构）
function settleReceivable(uint256 _id) external payable
```

### 2.2 关键设计

#### 权限控制

```solidity
modifier onlyCoreCompany() {
    require(userRoles[msg.sender] == UserRole.CORE_COMPANY, 
            "Only core company");
    _;
}

modifier onlySupplier() {
    require(userRoles[msg.sender] == UserRole.SUPPLIER, 
            "Only supplier");
    _;
}

modifier onlyFinancier() {
    require(userRoles[msg.sender] == UserRole.FINANCIER, 
            "Only financier");
    _;
}
```

#### 资金安全

```solidity
// 创建时必须锁定精确金额
function createReceivable(...) external payable {
    require(msg.value == _amount, "Must lock exact amount");
    // ...
}

// 批准融资时必须转账精确金额
function approveFinanceApplication(uint256 _appId) external payable {
    require(msg.value == app.financeAmount, "Incorrect ETH amount");
    payable(app.applicant).transfer(msg.value);  // 转给供应商
    // ...
}

// 结算时必须支付全额
function settleReceivable(uint256 _id) external payable {
    require(msg.value >= rec.amount, "Insufficient payment");
    payable(rec.owner).transfer(msg.value);  // 转给持有人
    // ...
}
```

#### 事件记录

```solidity
event UserRegistered(address indexed user, UserRole role, string name);
event ReceivableCreated(uint256 indexed id, address indexed issuer, address indexed supplier);
event ReceivableConfirmed(uint256 indexed id, address indexed supplier);
event FinanceApplicationSubmitted(uint256 indexed appId, uint256 indexed receivableId);
event FinanceApproved(uint256 indexed appId, uint256 indexed receivableId);
event ReceivableSettled(uint256 indexed id, address indexed owner);
```

### 2.3 部署与测试

#### 本地部署

```bash
# 启动Hardhat节点
npx hardhat node

# 部署合约
npx hardhat run scripts/deploy.js --network localhost
```

#### 单元测试

```javascript
describe("SupplyChainFinance", function () {
  it("应该允许核心企业创建应收账款", async function () {
    const tx = await contract.connect(coreCompany)
      .createReceivable(
        supplier.address,
        ethers.parseEther("100"),
        dueTime,
        "描述",
        "JX-001",
        { value: ethers.parseEther("100") }
      );
    // ...
  });
  
  it("应该允许供应商确认应收账款", async function () {
    await contract.connect(supplier).confirmReceivable(1);
    // ...
  });
});
```

---

## 第三部分：后端开发

### 3.1 后端职责

1. **JWT身份认证**：用户登录和权限验证
2. **数据查询优化**：缓存链上数据，快速查询
3. **事件监听同步**：监听合约事件，更新数据库
4. **API接口**：为前端提供RESTful API

### 3.2 核心服务

#### contractService.js

```javascript
class ContractService {
  constructor() {
    this.provider = new ethers.JsonRpcProvider('http://localhost:8545');
    this.wallet = new ethers.Wallet(process.env.PRIVATE_KEY, this.provider);
    this.contract = new ethers.Contract(
      process.env.CONTRACT_ADDRESS,
      ABI,
      this.wallet
    );
  }
  
  // 读取应收账款信息
  async getReceivable(id) {
    return await this.contract.receivables(id);
  }
  
  // 读取用户角色
  async getUserRole(address) {
    return await this.contract.userRoles(address);
  }
}
```

#### syncService.js

```javascript
// 监听合约事件，同步数据库
class SyncService {
  async start() {
    // 监听应收账款创建
    this.contract.on('ReceivableCreated', async (id, issuer, supplier, event) => {
      const rec = await contractService.getReceivable(id);
      await ReceivableIndex.create({
        receivable_id: id,
        issuer_address: issuer,
        owner_address: supplier,
        amount: rec.amount.toString(),
        // ...
      });
    });
    
    // 监听融资批准
    this.contract.on('FinanceApproved', async (appId, receivableId, event) => {
      await FinanceAppIndex.update(
        { approved: true, processed: true },
        { where: { application_id: appId } }
      );
      await ReceivableIndex.update(
        { financed: true },
        { where: { receivable_id: receivableId } }
      );
    });
  }
}
```

### 3.3 API接口设计

#### 应收账款接口

```javascript
// GET /api/receivables - 获取应收账款列表
router.get('/', authMiddleware, receivableController.list);

// GET /api/receivables/:id - 获取应收账款详情
router.get('/:id', authMiddleware, receivableController.detail);

// POST /api/receivables - 创建应收账款
router.post('/', authMiddleware, receivableController.create);

// POST /api/receivables/sync - 手动同步
router.post('/sync', authMiddleware, receivableController.sync);
```

#### 融资接口

```javascript
// GET /api/finance/applications - 获取融资申请列表
router.get('/applications', authMiddleware, financeController.list);

// POST /api/finance/apply - 申请融资
router.post('/apply', authMiddleware, financeController.apply);

// POST /api/finance/sync - 手动同步
router.post('/sync', authMiddleware, financeController.sync);
```

### 3.4 数据库设计

#### receivable_index 表

```sql
CREATE TABLE receivable_index (
  id INT AUTO_INCREMENT PRIMARY KEY,
  receivable_id INT NOT NULL UNIQUE,
  issuer_address VARCHAR(42) NOT NULL,
  owner_address VARCHAR(42) NOT NULL,
  supplier_address VARCHAR(42) NOT NULL,
  amount VARCHAR(78) NOT NULL,
  contract_number VARCHAR(100) NOT NULL,
  description TEXT,
  create_time TIMESTAMP,
  due_time TIMESTAMP,
  confirmed BOOLEAN DEFAULT FALSE,
  financed BOOLEAN DEFAULT FALSE,
  settled BOOLEAN DEFAULT FALSE,
  tx_hash VARCHAR(66),
  block_number INT
);
```

#### finance_app_index 表

```sql
CREATE TABLE finance_app_index (
  id INT AUTO_INCREMENT PRIMARY KEY,
  application_id INT NOT NULL UNIQUE,
  receivable_id INT NOT NULL,
  applicant_address VARCHAR(42) NOT NULL,
  financier_address VARCHAR(42) NOT NULL,
  finance_amount VARCHAR(78) NOT NULL,
  interest_rate INT NOT NULL,
  apply_time TIMESTAMP,
  approved BOOLEAN DEFAULT FALSE,
  processed BOOLEAN DEFAULT FALSE,
  tx_hash VARCHAR(66),
  block_number INT
);
```

---

## 第四部分：前端开发

### 4.1 前端架构

```
src/
├── components/          # 通用组件
├── pages/
│   ├── auth/           # 登录注册
│   ├── receivable/     # 应收账款相关
│   │   ├── CreateReceivable.tsx
│   │   ├── ReceivableList.tsx
│   │   ├── ConfirmReceivable.tsx
│   │   └── TransferReceivable.tsx
│   └── finance/        # 融资相关
│       ├── ApplyFinance.tsx
│       └── ApproveFinance.tsx
├── services/
│   ├── api.ts          # HTTP API封装
│   ├── contract.ts     # Web3合约调用
│   ├── receivable.ts   # 应收账款服务
│   └── finance.ts      # 融资服务
└── App.tsx
```

### 4.2 关键技术点

#### MetaMask集成

```typescript
// services/contract.ts
class ContractService {
  private provider?: ethers.BrowserProvider;
  private signer?: ethers.Signer;
  private contract?: ethers.Contract;
  
  async init() {
    if (!window.ethereum) {
      throw new Error('请安装MetaMask');
    }
    
    this.provider = new ethers.BrowserProvider(window.ethereum);
    this.signer = await this.provider.getSigner();
    this.contract = new ethers.Contract(
      CONTRACT_ADDRESS,
      ABI,
      this.signer
    );
  }
  
  async createReceivable(supplier, amount, dueTime, ...) {
    const tx = await this.contract!.createReceivable(
      supplier,
      amount,
      dueTime,
      ...,
      { value: amount }  // 锁定ETH
    );
    const receipt = await tx.wait();
    return { txHash: receipt.hash, blockNumber: receipt.blockNumber };
  }
}
```

#### 用户操作流程

```typescript
// pages/receivable/CreateReceivable.tsx
const handleSubmit = async (values: any) => {
  try {
    // 1. 确认对话框
    await modal.confirm({
      title: '确认创建应收账款',
      content: `将锁定 ${values.amount} ETH 到智能合约`,
      onOk: async () => {
        // 2. 调用MetaMask
        const { txHash } = await contractService.createReceivable(...);
        
        // 3. 同步到后端
        await receivableService.createReceivable({
          ...values,
          txHash
        });
        
        message.success('创建成功');
      }
    });
  } catch (error) {
    message.error('创建失败');
  }
};
```

#### 数据展示

```typescript
// pages/receivable/ReceivableList.tsx
const columns = [
  {
    title: '金额',
    dataIndex: 'amount',
    render: (amount: string) => {
      const ethAmount = (parseFloat(amount) / 1e18).toFixed(4);
      return `${ethAmount} ETH`;
    }
  },
  {
    title: '发行方',
    dataIndex: 'issuer',
    render: (addr: string) => 
      addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '-'
  },
  {
    title: '状态',
    dataIndex: 'status',
    render: (status: number) => {
      const statusMap = {
        0: { color: 'warning', text: '待确认' },
        1: { color: 'processing', text: '已确认' },
        2: { color: 'blue', text: '已转让' },
        3: { color: 'success', text: '已融资' }
      };
      const config = statusMap[status];
      return <Tag color={config.color}>{config.text}</Tag>;
    }
  }
];
```

### 4.3 状态管理

使用React Hooks进行简单状态管理：

```typescript
const [receivables, setReceivables] = useState<Receivable[]>([]);
const [loading, setLoading] = useState(false);

useEffect(() => {
  fetchReceivables();
}, []);

const fetchReceivables = async () => {
  setLoading(true);
  try {
    const result = await receivableService.getReceivables();
    setReceivables(result.items || []);
  } finally {
    setLoading(false);
  }
};
```

---

## 第五部分：部署与运维

### 5.1 开发环境部署

#### 1. 启动Hardhat节点

```bash
cd contracts
npx hardhat node
```

保持这个终端运行。

#### 2. 部署合约

```bash
# 新终端
cd contracts
npx hardhat run scripts/deploy.js --network localhost
```

记录合约地址，例如：`0x5FbDB2315678afecb367f032d93F642f64180aa3`

#### 3. 配置环境变量

**backend/.env**:
```env
CONTRACT_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
RPC_URL=http://localhost:8545
```

**frontend/.env**:
```env
VITE_CONTRACT_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
VITE_API_URL=http://localhost:5000/api
```

#### 4. 启动服务

```bash
# 后端
cd backend
npm start

# 前端（新终端）
cd frontend
npm run dev
```

### 5.2 生产环境部署（示例）

#### 1. 部署到测试网（Sepolia）

```bash
# 配置 hardhat.config.js
networks: {
  sepolia: {
    url: process.env.SEPOLIA_RPC_URL,
    accounts: [process.env.DEPLOYER_PRIVATE_KEY],
    chainId: 11155111
  }
}

# 部署
npx hardhat run scripts/deploy.js --network sepolia
```

#### 2. 后端部署

```bash
# 使用 PM2 管理进程
pm2 start npm --name "scf-backend" -- start
pm2 save
pm2 startup
```

#### 3. 前端部署

```bash
# 构建
npm run build

# 使用 Nginx 部署
# nginx.conf
server {
  listen 80;
  server_name your-domain.com;
  root /var/www/scf-frontend/dist;
  
  location /api {
    proxy_pass http://localhost:5000;
  }
}
```

### 5.3 监控与日志

#### 后端日志

```javascript
// 使用 Winston
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});
```

#### 合约事件监控

```javascript
// 监控所有重要事件
contract.on('ReceivableCreated', (id, issuer, supplier) => {
  logger.info(`新应收账款: ID=${id}, 发行方=${issuer}`);
});

contract.on('FinanceApproved', (appId, receivableId) => {
  logger.info(`融资批准: appId=${appId}, receivableId=${receivableId}`);
});
```

---

## 第六部分：测试与调试

### 6.1 单元测试

#### 智能合约测试

```javascript
// test/SupplyChainFinance.test.js
describe("完整流程测试", function () {
  it("应该完成从创建到结算的完整流程", async function () {
    // 1. 注册用户
    await contract.connect(coreCompany).registerUser(1, "CoreCo");
    await contract.connect(supplier).registerUser(2, "Supplier");
    await contract.connect(financier).registerUser(3, "Bank");
    
    // 2. 创建应收账款
    const amount = ethers.parseEther("100");
    await contract.connect(coreCompany).createReceivable(
      supplier.address,
      amount,
      futureTime,
      "描述",
      "JX-001",
      { value: amount }
    );
    
    // 3. 供应商确认
    await contract.connect(supplier).confirmReceivable(1);
    
    // 4. 申请融资
    await contract.connect(supplier).applyForFinance(
      1,
      financier.address,
      ethers.parseEther("90"),
      1000  // 10%
    );
    
    // 5. 批准融资
    await contract.connect(financier).approveFinanceApplication(1, {
      value: ethers.parseEther("90")
    });
    
    // 6. 结算
    await ethers.provider.send("evm_increaseTime", [30 * 24 * 60 * 60]);
    await contract.connect(coreCompany).settleReceivable(1, {
      value: amount
    });
    
    // 验证状态
    const rec = await contract.receivables(1);
    expect(rec.settled).to.be.true;
  });
});
```

### 6.2 集成测试

#### API测试

```python
# tests/test_api.py
def test_complete_workflow():
    # 1. 注册用户
    resp = requests.post(f"{BASE_URL}/auth/register", json={
        "username": "core_company",
        "address": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
    })
    token = resp.json()['token']
    
    # 2. 创建应收账款
    resp = requests.post(f"{BASE_URL}/receivables", 
        headers={"Authorization": f"Bearer {token}"},
        json={
            "supplier": "0x70997970C51812dc3A010C7d01b50e0d17dc79C8",
            "amount": "100000000000000000000",
            "dueTime": "2025-11-30T00:00:00Z",
            "contractNumber": "JX-001"
        }
    )
    assert resp.status_code == 200
    
    # 3. 查询应收账款
    resp = requests.get(f"{BASE_URL}/receivables",
        headers={"Authorization": f"Bearer {token}"}
    )
    assert len(resp.json()['data']['items']) > 0
```

### 6.3 常见问题调试

#### 问题1：MetaMask不弹窗

**原因**：
- 网络未连接
- 合约地址错误
- Gas费不足

**调试步骤**：
```typescript
// 1. 检查网络
const network = await provider.getNetwork();
console.log('当前网络:', network.chainId);

// 2. 检查余额
const balance = await provider.getBalance(address);
console.log('余额:', ethers.formatEther(balance));

// 3. 检查Gas估算
const gasEstimate = await contract.createReceivable.estimateGas(...);
console.log('预估Gas:', gasEstimate.toString());
```

#### 问题2：交易失败但已上链

**原因**：
- 合约执行失败（require检查不通过）
- 资金不足
- 权限不足

**调试步骤**：
```typescript
const tx = await contract.someFunction(...);
const receipt = await tx.wait();

// 检查交易状态
if (receipt.status === 0) {
  console.error('交易执行失败');
  // 查看交易详情
  const txDetails = await provider.getTransaction(tx.hash);
  console.log('交易详情:', txDetails);
}
```

#### 问题3：数据不同步

**原因**：
- 事件监听器未启动
- 数据库连接失败
- 合约地址配置错误

**调试步骤**：
```javascript
// 1. 手动触发同步
await syncService.syncReceivables();

// 2. 检查事件监听
contract.once('ReceivableCreated', (...args) => {
  console.log('捕获到事件:', args);
});

// 3. 查看合约事件历史
const filter = contract.filters.ReceivableCreated();
const events = await contract.queryFilter(filter, 0, 'latest');
console.log('历史事件:', events);
```

---

## 附录

### A. 环境变量完整清单

#### backend/.env
```env
# 服务器配置
PORT=5000
NODE_ENV=development

# 数据库配置
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_PASSWORD=your_password
DB_NAME=supplychain_finance

# JWT配置
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=7d

# 区块链配置
CONTRACT_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
RPC_URL=http://localhost:8545
CHAIN_ID=31337
```

#### frontend/.env
```env
VITE_API_URL=http://localhost:5000/api
VITE_CONTRACT_ADDRESS=0x5FbDB2315678afecb367f032d93F642f64180aa3
```

### B. 常用命令速查

```bash
# 智能合约
npx hardhat compile          # 编译合约
npx hardhat test            # 运行测试
npx hardhat node            # 启动本地网络
npx hardhat run scripts/deploy.js --network localhost  # 部署

# 后端
npm start                   # 启动服务
npm run dev                 # 开发模式
npm test                    # 运行测试

# 前端
npm run dev                 # 开发模式
npm run build               # 构建生产版本
npm run preview             # 预览生产版本

# 数据库
mysql -u root -p            # 登录MySQL
CREATE DATABASE supplychain_finance;  # 创建数据库
SOURCE database/schema.sql;  # 导入表结构
```

### C. 参考资料

- [Solidity文档](https://docs.soliditylang.org/)
- [Hardhat文档](https://hardhat.org/docs)
- [ethers.js v6文档](https://docs.ethers.org/v6/)
- [Express.js文档](https://expressjs.com/)
- [React文档](https://react.dev/)
- [Ant Design](https://ant.design/)
- [MetaMask开发者文档](https://docs.metamask.io/)

---

## 结语

这份文档涵盖了项目的完整开发流程，从业务理解到技术实现，从本地开发到生产部署。

**关键要点**：
1. 理解业务流程和资金流动
2. 合约安全设计（权限控制、资金安全）
3. 前后端分离架构
4. MetaMask集成的最佳实践
5. 完善的测试和调试流程

**后续优化方向**：
- 添加重入保护
- 优化Gas消耗
- 增加紧急暂停机制
- 完善权限控制
- 添加多签钱包支持

---

**作者：Xu200**  
**联系方式：GitHub Issues**

祝开发顺利！🎉

