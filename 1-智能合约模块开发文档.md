# æ™ºèƒ½åˆçº¦æ¨¡å—å¼€å‘æ–‡æ¡£

## ğŸ“Œ æ¨¡å—æ¦‚è¿°

æ™ºèƒ½åˆçº¦æ˜¯æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒï¼Œè´Ÿè´£åœ¨åŒºå—é“¾ä¸Šè®°å½•å’Œç®¡ç†åº”æ”¶è´¦æ¬¾çš„ç”Ÿå‘½å‘¨æœŸï¼ŒåŒ…æ‹¬åˆ›å»ºã€ç¡®è®¤ã€è½¬è®©å’Œèèµ„æ ‡è®°ã€‚

---

## ğŸ¯ å¼€å‘ç›®æ ‡

- å®ç°åº”æ”¶è´¦æ¬¾çš„é“¾ä¸Šå­˜å‚¨å’ŒçŠ¶æ€ç®¡ç†
- ç¡®ä¿äº¤æ˜“çš„ä¸å¯ç¯¡æ”¹æ€§å’Œå¯è¿½æº¯æ€§
- æä¾›æ¸…æ™°çš„æƒé™æ§åˆ¶å’Œäº‹ä»¶æ—¥å¿—
- ä¿æŒåˆçº¦ç®€æ´é«˜æ•ˆï¼Œé™ä½ Gas è´¹ç”¨

---

## ğŸ› ï¸ æŠ€æœ¯æ ˆ

- **å¼€å‘è¯­è¨€**: Solidity ^0.8.0
- **å¼€å‘æ¡†æ¶**: Hardhat
- **æµ‹è¯•ç½‘ç»œ**: Sepolia / Goerli
- **é’±åŒ…å·¥å…·**: MetaMask
- **åº“ä¾èµ–**: OpenZeppelin (å¯é€‰ï¼Œç”¨äºå®‰å…¨æ€§å¢å¼º)

---

## ğŸ“Š æ•°æ®ç»“æ„è®¾è®¡

### 1. åº”æ”¶è´¦æ¬¾ç»“æ„ä½“ (Receivable)

```solidity
struct Receivable {
    uint256 id;                 // åº”æ”¶è´¦æ¬¾å”¯ä¸€ID
    address issuer;             // å‘è¡Œæ–¹ï¼ˆæ ¸å¿ƒä¼ä¸šï¼‰
    address owner;              // å½“å‰æŒæœ‰äººï¼ˆåˆå§‹ä¸ºä¾›åº”å•†ï¼‰
    address supplier;           // åŸå§‹ä¾›åº”å•†åœ°å€
    uint256 amount;             // é‡‘é¢ï¼ˆå•ä½ï¼šweiï¼‰
    uint256 createTime;         // åˆ›å»ºæ—¶é—´æˆ³
    uint256 dueTime;            // åˆ°æœŸæ—¶é—´æˆ³
    bool confirmed;             // æ˜¯å¦å·²ç¡®è®¤
    bool financed;              // æ˜¯å¦å·²èèµ„
    bool settled;               // æ˜¯å¦å·²ç»“ç®—
    string description;         // æè¿°ä¿¡æ¯
    string contractNumber;      // åˆåŒç¼–å·
}
```

### 2. ç”¨æˆ·è§’è‰²æšä¸¾

```solidity
enum UserRole {
    NONE,           // æœªæ³¨å†Œ
    CORE_COMPANY,   // æ ¸å¿ƒä¼ä¸š
    SUPPLIER,       // ä¾›åº”å•†
    FINANCIER       // é‡‘èæœºæ„
}
```

### 3. èèµ„ç”³è¯·ç»“æ„ä½“

```solidity
struct FinanceApplication {
    uint256 receivableId;       // å…³è”çš„åº”æ”¶è´¦æ¬¾ID
    address applicant;          // ç”³è¯·äºº
    address financier;          // é‡‘èæœºæ„
    uint256 applyTime;          // ç”³è¯·æ—¶é—´
    uint256 financeAmount;      // èèµ„é‡‘é¢
    uint256 interestRate;       // åˆ©ç‡ï¼ˆåŸºç‚¹ï¼Œå¦‚500è¡¨ç¤º5%ï¼‰
    bool approved;              // æ˜¯å¦æ‰¹å‡†
    bool processed;             // æ˜¯å¦å·²å¤„ç†
}
```

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½å®ç°

### 1. ç”¨æˆ·æ³¨å†Œä¸è§’è‰²ç®¡ç†

```solidity
// çŠ¶æ€å˜é‡
mapping(address => UserRole) public userRoles;
mapping(address => string) public userNames;

// æ³¨å†Œç”¨æˆ·
function registerUser(UserRole _role, string memory _name) external {
    require(userRoles[msg.sender] == UserRole.NONE, "Already registered");
    require(_role != UserRole.NONE, "Invalid role");
    
    userRoles[msg.sender] = _role;
    userNames[msg.sender] = _name;
    
    emit UserRegistered(msg.sender, _role, _name);
}

// è·å–ç”¨æˆ·è§’è‰²
function getUserRole(address _user) external view returns (UserRole) {
    return userRoles[_user];
}
```

### 2. åˆ›å»ºåº”æ”¶è´¦æ¬¾

```solidity
// çŠ¶æ€å˜é‡
uint256 public receivableCounter;
mapping(uint256 => Receivable) public receivables;

// åˆ›å»ºåº”æ”¶è´¦æ¬¾ï¼ˆä»…æ ¸å¿ƒä¼ä¸šï¼‰
function createReceivable(
    address _supplier,
    uint256 _amount,
    uint256 _dueTime,
    string memory _description,
    string memory _contractNumber
) external onlyCoreCompany returns (uint256) {
    require(_supplier != address(0), "Invalid supplier address");
    require(_amount > 0, "Amount must be positive");
    require(_dueTime > block.timestamp, "Due time must be in future");
    
    receivableCounter++;
    uint256 newId = receivableCounter;
    
    receivables[newId] = Receivable({
        id: newId,
        issuer: msg.sender,
        owner: _supplier,
        supplier: _supplier,
        amount: _amount,
        createTime: block.timestamp,
        dueTime: _dueTime,
        confirmed: false,
        financed: false,
        settled: false,
        description: _description,
        contractNumber: _contractNumber
    });
    
    emit ReceivableCreated(newId, msg.sender, _supplier, _amount);
    
    return newId;
}
```

### 3. ç¡®è®¤åº”æ”¶è´¦æ¬¾

```solidity
// ä¾›åº”å•†ç¡®è®¤åº”æ”¶è´¦æ¬¾
function confirmReceivable(uint256 _id) external {
    Receivable storage rec = receivables[_id];
    
    require(rec.id != 0, "Receivable does not exist");
    require(rec.owner == msg.sender, "Not the owner");
    require(!rec.confirmed, "Already confirmed");
    
    rec.confirmed = true;
    
    emit ReceivableConfirmed(_id, msg.sender);
}
```

### 4. è½¬è®©åº”æ”¶è´¦æ¬¾

```solidity
// è½¬è®©åº”æ”¶è´¦æ¬¾
function transferReceivable(uint256 _id, address _newOwner) external {
    Receivable storage rec = receivables[_id];
    
    require(rec.id != 0, "Receivable does not exist");
    require(rec.owner == msg.sender, "Not the owner");
    require(rec.confirmed, "Not confirmed yet");
    require(!rec.settled, "Already settled");
    require(_newOwner != address(0), "Invalid new owner");
    
    address oldOwner = rec.owner;
    rec.owner = _newOwner;
    
    emit ReceivableTransferred(_id, oldOwner, _newOwner);
}
```

### 5. èèµ„ç”³è¯·ä¸å®¡æ‰¹

```solidity
// çŠ¶æ€å˜é‡
uint256 public financeApplicationCounter;
mapping(uint256 => FinanceApplication) public financeApplications;
mapping(uint256 => uint256[]) public receivableToApplications;

// ç”³è¯·èèµ„
function applyForFinance(
    uint256 _receivableId,
    address _financier,
    uint256 _financeAmount,
    uint256 _interestRate
) external returns (uint256) {
    Receivable storage rec = receivables[_receivableId];
    
    require(rec.id != 0, "Receivable does not exist");
    require(rec.owner == msg.sender, "Not the owner");
    require(rec.confirmed, "Not confirmed yet");
    require(!rec.financed, "Already financed");
    require(userRoles[_financier] == UserRole.FINANCIER, "Invalid financier");
    require(_financeAmount <= rec.amount, "Amount exceeds receivable");
    
    financeApplicationCounter++;
    uint256 appId = financeApplicationCounter;
    
    financeApplications[appId] = FinanceApplication({
        receivableId: _receivableId,
        applicant: msg.sender,
        financier: _financier,
        applyTime: block.timestamp,
        financeAmount: _financeAmount,
        interestRate: _interestRate,
        approved: false,
        processed: false
    });
    
    receivableToApplications[_receivableId].push(appId);
    
    emit FinanceApplicationSubmitted(appId, _receivableId, msg.sender, _financier);
    
    return appId;
}

// å®¡æ‰¹èèµ„ç”³è¯·ï¼ˆä»…é‡‘èæœºæ„ï¼‰
function approveFinanceApplication(uint256 _appId, bool _approve) external {
    FinanceApplication storage app = financeApplications[_appId];
    
    require(app.financier == msg.sender, "Not the assigned financier");
    require(!app.processed, "Already processed");
    
    app.approved = _approve;
    app.processed = true;
    
    if (_approve) {
        Receivable storage rec = receivables[app.receivableId];
        rec.financed = true;
        
        emit FinanceApproved(_appId, app.receivableId);
    } else {
        emit FinanceRejected(_appId, app.receivableId);
    }
}
```

### 6. ç»“ç®—åº”æ”¶è´¦æ¬¾

```solidity
// ç»“ç®—åº”æ”¶è´¦æ¬¾ï¼ˆä»…å‘è¡Œæ–¹ï¼‰
function settleReceivable(uint256 _id) external onlyCoreCompany {
    Receivable storage rec = receivables[_id];
    
    require(rec.id != 0, "Receivable does not exist");
    require(rec.issuer == msg.sender, "Not the issuer");
    require(rec.confirmed, "Not confirmed yet");
    require(!rec.settled, "Already settled");
    
    rec.settled = true;
    
    emit ReceivableSettled(_id, rec.owner);
}
```

---

## ğŸ” æƒé™æ§åˆ¶ï¼ˆModifiersï¼‰

```solidity
modifier onlyCoreCompany() {
    require(userRoles[msg.sender] == UserRole.CORE_COMPANY, "Only core company");
    _;
}

modifier onlySupplier() {
    require(userRoles[msg.sender] == UserRole.SUPPLIER, "Only supplier");
    _;
}

modifier onlyFinancier() {
    require(userRoles[msg.sender] == UserRole.FINANCIER, "Only financier");
    _;
}
```

---

## ğŸ“¢ äº‹ä»¶å®šä¹‰

```solidity
event UserRegistered(address indexed user, UserRole role, string name);
event ReceivableCreated(uint256 indexed id, address indexed issuer, address indexed supplier, uint256 amount);
event ReceivableConfirmed(uint256 indexed id, address indexed confirmer);
event ReceivableTransferred(uint256 indexed id, address indexed from, address indexed to);
event FinanceApplicationSubmitted(uint256 indexed appId, uint256 indexed receivableId, address indexed applicant, address financier);
event FinanceApproved(uint256 indexed appId, uint256 indexed receivableId);
event FinanceRejected(uint256 indexed appId, uint256 indexed receivableId);
event ReceivableSettled(uint256 indexed id, address indexed finalOwner);
```

---

## ğŸ§ª æŸ¥è¯¢å‡½æ•°

```solidity
// è·å–åº”æ”¶è´¦æ¬¾è¯¦æƒ…
function getReceivable(uint256 _id) external view returns (Receivable memory) {
    return receivables[_id];
}

// è·å–ç”¨æˆ·æ‹¥æœ‰çš„åº”æ”¶è´¦æ¬¾åˆ—è¡¨
function getReceivablesByOwner(address _owner) external view returns (uint256[] memory) {
    uint256[] memory result = new uint256[](receivableCounter);
    uint256 count = 0;
    
    for (uint256 i = 1; i <= receivableCounter; i++) {
        if (receivables[i].owner == _owner) {
            result[count] = i;
            count++;
        }
    }
    
    // è°ƒæ•´æ•°ç»„å¤§å°
    uint256[] memory finalResult = new uint256[](count);
    for (uint256 i = 0; i < count; i++) {
        finalResult[i] = result[i];
    }
    
    return finalResult;
}

// è·å–ç”¨æˆ·å‘è¡Œçš„åº”æ”¶è´¦æ¬¾åˆ—è¡¨
function getReceivablesByIssuer(address _issuer) external view returns (uint256[] memory) {
    uint256[] memory result = new uint256[](receivableCounter);
    uint256 count = 0;
    
    for (uint256 i = 1; i <= receivableCounter; i++) {
        if (receivables[i].issuer == _issuer) {
            result[count] = i;
            count++;
        }
    }
    
    uint256[] memory finalResult = new uint256[](count);
    for (uint256 i = 0; i < count; i++) {
        finalResult[i] = result[i];
    }
    
    return finalResult;
}

// è·å–èèµ„ç”³è¯·è¯¦æƒ…
function getFinanceApplication(uint256 _appId) external view returns (FinanceApplication memory) {
    return financeApplications[_appId];
}

// è·å–åº”æ”¶è´¦æ¬¾çš„æ‰€æœ‰èèµ„ç”³è¯·
function getApplicationsByReceivable(uint256 _receivableId) external view returns (uint256[] memory) {
    return receivableToApplications[_receivableId];
}
```

---

## ğŸ“¦ Hardhat é…ç½®

### 1. é¡¹ç›®åˆå§‹åŒ–

```bash
mkdir contracts
cd contracts
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox
npx hardhat init
```

### 2. hardhat.config.js

```javascript
require("@nomicfoundation/hardhat-toolbox");
require('dotenv').config();

module.exports = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    hardhat: {
      chainId: 1337
    },
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    }
  },
  paths: {
    sources: "./contracts",
    tests: "./test",
    cache: "./cache",
    artifacts: "./artifacts"
  }
};
```

### 3. éƒ¨ç½²è„šæœ¬ (scripts/deploy.js)

```javascript
const hre = require("hardhat");

async function main() {
  console.log("å¼€å§‹éƒ¨ç½² SupplyChainFinance åˆçº¦...");

  const SupplyChainFinance = await hre.ethers.getContractFactory("SupplyChainFinance");
  const contract = await SupplyChainFinance.deploy();

  await contract.waitForDeployment();

  const address = await contract.getAddress();
  console.log("åˆçº¦éƒ¨ç½²æˆåŠŸï¼");
  console.log("åˆçº¦åœ°å€:", address);

  // ä¿å­˜åˆçº¦åœ°å€åˆ°æ–‡ä»¶
  const fs = require('fs');
  const deployInfo = {
    address: address,
    network: hre.network.name,
    deployTime: new Date().toISOString()
  };
  
  fs.writeFileSync(
    './deployment.json',
    JSON.stringify(deployInfo, null, 2)
  );

  console.log("éƒ¨ç½²ä¿¡æ¯å·²ä¿å­˜åˆ° deployment.json");
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### test/SupplyChainFinance.test.js

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("SupplyChainFinance", function () {
  let contract;
  let coreCompany, supplier, financier;

  beforeEach(async function () {
    [coreCompany, supplier, financier] = await ethers.getSigners();

    const SupplyChainFinance = await ethers.getContractFactory("SupplyChainFinance");
    contract = await SupplyChainFinance.deploy();
    await contract.waitForDeployment();

    // æ³¨å†Œç”¨æˆ·
    await contract.connect(coreCompany).registerUser(1, "Core Company A");
    await contract.connect(supplier).registerUser(2, "Supplier B");
    await contract.connect(financier).registerUser(3, "Bank C");
  });

  it("åº”è¯¥æˆåŠŸæ³¨å†Œç”¨æˆ·", async function () {
    const role = await contract.getUserRole(coreCompany.address);
    expect(role).to.equal(1); // CORE_COMPANY
  });

  it("åº”è¯¥æˆåŠŸåˆ›å»ºåº”æ”¶è´¦æ¬¾", async function () {
    const amount = ethers.parseEther("100");
    const dueTime = Math.floor(Date.now() / 1000) + 86400 * 30; // 30å¤©å

    await contract.connect(coreCompany).createReceivable(
      supplier.address,
      amount,
      dueTime,
      "Payment for goods",
      "CONTRACT-001"
    );

    const receivable = await contract.getReceivable(1);
    expect(receivable.amount).to.equal(amount);
    expect(receivable.owner).to.equal(supplier.address);
  });

  it("åº”è¯¥æˆåŠŸç¡®è®¤åº”æ”¶è´¦æ¬¾", async function () {
    const amount = ethers.parseEther("100");
    const dueTime = Math.floor(Date.now() / 1000) + 86400 * 30;

    await contract.connect(coreCompany).createReceivable(
      supplier.address,
      amount,
      dueTime,
      "Payment for goods",
      "CONTRACT-001"
    );

    await contract.connect(supplier).confirmReceivable(1);

    const receivable = await contract.getReceivable(1);
    expect(receivable.confirmed).to.be.true;
  });

  it("åº”è¯¥æˆåŠŸè½¬è®©åº”æ”¶è´¦æ¬¾", async function () {
    const amount = ethers.parseEther("100");
    const dueTime = Math.floor(Date.now() / 1000) + 86400 * 30;

    await contract.connect(coreCompany).createReceivable(
      supplier.address,
      amount,
      dueTime,
      "Payment for goods",
      "CONTRACT-001"
    );

    await contract.connect(supplier).confirmReceivable(1);
    await contract.connect(supplier).transferReceivable(1, financier.address);

    const receivable = await contract.getReceivable(1);
    expect(receivable.owner).to.equal(financier.address);
  });

  it("åº”è¯¥æˆåŠŸç”³è¯·å’Œå®¡æ‰¹èèµ„", async function () {
    const amount = ethers.parseEther("100");
    const dueTime = Math.floor(Date.now() / 1000) + 86400 * 30;

    await contract.connect(coreCompany).createReceivable(
      supplier.address,
      amount,
      dueTime,
      "Payment for goods",
      "CONTRACT-001"
    );

    await contract.connect(supplier).confirmReceivable(1);

    const financeAmount = ethers.parseEther("80");
    await contract.connect(supplier).applyForFinance(
      1,
      financier.address,
      financeAmount,
      500 // 5% åˆ©ç‡
    );

    await contract.connect(financier).approveFinanceApplication(1, true);

    const receivable = await contract.getReceivable(1);
    expect(receivable.financed).to.be.true;
  });
});
```

---

## ğŸ“ å¼€å‘æ­¥éª¤

1. **åˆå§‹åŒ– Hardhat é¡¹ç›®** (10åˆ†é’Ÿ)
2. **ç¼–å†™ SupplyChainFinance.sol åˆçº¦** (1-2å°æ—¶)
3. **ç¼–å†™æµ‹è¯•ç”¨ä¾‹** (30åˆ†é’Ÿ)
4. **æœ¬åœ°æµ‹è¯•éƒ¨ç½²** (20åˆ†é’Ÿ)
5. **éƒ¨ç½²åˆ°æµ‹è¯•ç½‘** (20åˆ†é’Ÿ)
6. **å¯¼å‡º ABI ä¾›å‰ç«¯ä½¿ç”¨** (10åˆ†é’Ÿ)

**é¢„è®¡æ€»æ—¶é—´ï¼š3-4å°æ—¶**

---

## ğŸ äº¤ä»˜ç‰©

- [x] SupplyChainFinance.sol åˆçº¦æºç 
- [x] éƒ¨ç½²è„šæœ¬
- [x] æµ‹è¯•ç”¨ä¾‹
- [x] Hardhat é…ç½®æ–‡ä»¶
- [x] åˆçº¦ ABI JSON æ–‡ä»¶
- [x] éƒ¨ç½²åœ°å€è®°å½•æ–‡ä»¶

---

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **Gas ä¼˜åŒ–**: é¿å…åœ¨å¾ªç¯ä¸­è¿›è¡ŒçŠ¶æ€å†™å…¥æ“ä½œ
2. **å®‰å…¨æ€§**: æ‰€æœ‰å¤–éƒ¨è°ƒç”¨éƒ½è¦è¿›è¡Œæƒé™æ£€æŸ¥
3. **äº‹ä»¶æ—¥å¿—**: å…³é”®æ“ä½œå¿…é¡»è§¦å‘äº‹ä»¶ï¼Œä¾¿äºå‰ç«¯ç›‘å¬
4. **æµ‹è¯•ç½‘æµ‹è¯•**: éƒ¨ç½²å‰åŠ¡å¿…åœ¨æµ‹è¯•ç½‘å……åˆ†æµ‹è¯•
5. **ç§é’¥å®‰å…¨**: ä½¿ç”¨ .env æ–‡ä»¶ç®¡ç†ç§é’¥ï¼Œä¸è¦æäº¤åˆ° Git

---

## ğŸ”— ç›¸å…³èµ„æº

- Hardhat æ–‡æ¡£: https://hardhat.org/docs
- Solidity æ–‡æ¡£: https://docs.soliditylang.org
- OpenZeppelin: https://docs.openzeppelin.com
- Sepolia æµ‹è¯•ç½‘æ°´é¾™å¤´: https://sepoliafaucet.com

