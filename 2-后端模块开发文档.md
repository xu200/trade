# 后端模块开发文档

## 📌 模块概述

**后端是系统的核心**，负责业务逻辑处理、权限控制、与智能合约交互。前端通过后端API操作，不直接调用智能合约。

---

## 🎯 开发目标

- **统一业务入口**：前端所有操作通过后端API
- **权限控制**：基于JWT的身份认证和角色权限管理
- **智能合约代理**：后端托管账户，统一与区块链交互
- **数据缓存优化**：缓存链上数据，提升查询效率
- **业务逻辑处理**：参数验证、数据校验、通知发送等
- **交易管理**：交易状态追踪、失败重试、历史记录

---

## 🛠️ 技术栈

- **运行环境**: Node.js 18+
- **Web框架**: Express.js
- **数据库**: MySQL 8.0
- **ORM**: Sequelize
- **Web3库**: ethers.js
- **其他工具**: 
  - dotenv (环境变量管理)
  - cors (跨域支持)
  - morgan (日志记录)
  - joi (参数校验)
  - jsonwebtoken (JWT认证)
  - bcrypt (密码加密，可选)

---

## 📊 数据库设计

### 1. 用户表 (users)

```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    wallet_address VARCHAR(42) UNIQUE NOT NULL,
    role ENUM('core_company', 'supplier', 'financier') NOT NULL,
    company_name VARCHAR(100) NOT NULL,
    contact_person VARCHAR(50),
    contact_phone VARCHAR(20),
    contact_email VARCHAR(100),
    credit_rating INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_wallet (wallet_address),
    INDEX idx_role (role)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2. 应收账款索引表 (receivables_index)

```sql
CREATE TABLE receivables_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    receivable_id INT UNIQUE NOT NULL,
    issuer_address VARCHAR(42) NOT NULL,
    owner_address VARCHAR(42) NOT NULL,
    supplier_address VARCHAR(42) NOT NULL,
    amount DECIMAL(30, 0) NOT NULL,
    contract_number VARCHAR(100),
    description TEXT,
    create_time TIMESTAMP,
    due_time TIMESTAMP,
    confirmed BOOLEAN DEFAULT FALSE,
    financed BOOLEAN DEFAULT FALSE,
    settled BOOLEAN DEFAULT FALSE,
    tx_hash VARCHAR(66),
    block_number INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_receivable_id (receivable_id),
    INDEX idx_issuer (issuer_address),
    INDEX idx_owner (owner_address),
    INDEX idx_supplier (supplier_address),
    INDEX idx_status (confirmed, financed, settled)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3. 融资申请索引表 (finance_applications_index)

```sql
CREATE TABLE finance_applications_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    application_id INT UNIQUE NOT NULL,
    receivable_id INT NOT NULL,
    applicant_address VARCHAR(42) NOT NULL,
    financier_address VARCHAR(42) NOT NULL,
    finance_amount DECIMAL(30, 0) NOT NULL,
    interest_rate INT NOT NULL,
    apply_time TIMESTAMP,
    approved BOOLEAN DEFAULT FALSE,
    processed BOOLEAN DEFAULT FALSE,
    tx_hash VARCHAR(66),
    block_number INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_application_id (application_id),
    INDEX idx_receivable (receivable_id),
    INDEX idx_applicant (applicant_address),
    INDEX idx_financier (financier_address),
    INDEX idx_status (processed, approved)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 4. 交易历史表 (transaction_history)

```sql
CREATE TABLE transaction_history (
    id INT AUTO_INCREMENT PRIMARY KEY,
    tx_hash VARCHAR(66) UNIQUE NOT NULL,
    from_address VARCHAR(42) NOT NULL,
    to_address VARCHAR(42),
    tx_type ENUM('create', 'confirm', 'transfer', 'apply_finance', 'approve_finance', 'settle') NOT NULL,
    related_id INT,
    block_number INT,
    gas_used INT,
    timestamp TIMESTAMP,
    status ENUM('pending', 'success', 'failed') DEFAULT 'pending',
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_tx_hash (tx_hash),
    INDEX idx_from (from_address),
    INDEX idx_type (tx_type),
    INDEX idx_related (related_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 5. 系统配置表 (system_config)

```sql
CREATE TABLE system_config (
    id INT AUTO_INCREMENT PRIMARY KEY,
    config_key VARCHAR(50) UNIQUE NOT NULL,
    config_value TEXT,
    description VARCHAR(200),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- 插入初始配置
INSERT INTO system_config (config_key, config_value, description) VALUES
('contract_address', '', '智能合约地址'),
('network_id', '1337', '网络ID'),
('last_synced_block', '0', '最后同步的区块号');
```

---

## 🏗️ 项目结构

```
backend/
├── src/
│   ├── config/
│   │   ├── database.js          # 数据库配置
│   │   ├── web3.js              # Web3配置
│   │   └── contract.js          # 合约配置
│   ├── models/
│   │   ├── User.js              # 用户模型
│   │   ├── ReceivableIndex.js  # 应收账款索引模型
│   │   ├── FinanceAppIndex.js  # 融资申请索引模型
│   │   └── TransactionHistory.js # 交易历史模型
│   ├── controllers/
│   │   ├── userController.js    # 用户控制器
│   │   ├── receivableController.js # 应收账款控制器
│   │   ├── financeController.js # 融资控制器
│   │   └── statsController.js   # 统计控制器
│   ├── services/
│   │   ├── web3Service.js       # Web3服务
│   │   ├── contractService.js   # 合约交互服务
│   │   └── syncService.js       # 区块链同步服务
│   ├── routes/
│   │   ├── index.js             # 路由汇总
│   │   ├── authRoutes.js        # 认证路由（登录/注册）
│   │   ├── receivableRoutes.js # 应收账款路由
│   │   ├── financeRoutes.js    # 融资路由
│   │   └── statsRoutes.js      # 统计路由
│   ├── middleware/
│   │   ├── auth.js              # JWT认证中间件
│   │   ├── roleCheck.js         # 角色权限中间件
│   │   ├── validator.js         # 参数校验中间件
│   │   └── errorHandler.js     # 错误处理中间件
│   ├── utils/
│   │   ├── logger.js            # 日志工具
│   │   └── response.js          # 响应格式化工具
│   └── app.js                   # 应用入口
├── scripts/
│   └── initDB.js                # 数据库初始化脚本
├── .env.example                 # 环境变量示例
├── package.json
└── README.md
```

---

## 🔧 核心功能实现

### 1. 合约服务封装 (services/contractService.js)

**重要：后端使用托管账户与智能合约交互，前端不直接调用合约**

```javascript
const { ethers } = require('ethers');
const contractABI = require('../contracts/SupplyChainFinance.json');

class Web3Service {
  constructor() {
    this.provider = new ethers.JsonRpcProvider(process.env.RPC_URL);
    this.contractAddress = process.env.CONTRACT_ADDRESS;
    this.contract = new ethers.Contract(
      this.contractAddress,
      contractABI.abi,
      this.provider
    );
  }

  // 获取合约实例（带签名者）
  getContractWithSigner(privateKey) {
    const wallet = new ethers.Wallet(privateKey, this.provider);
    return new ethers.Contract(
      this.contractAddress,
      contractABI.abi,
      wallet
    );
  }

  // 监听合约事件
  async listenToEvents() {
    // 监听应收账款创建事件
    this.contract.on('ReceivableCreated', async (id, issuer, supplier, amount, event) => {
      console.log('ReceivableCreated:', { id, issuer, supplier, amount: amount.toString() });
      await this.syncReceivable(id);
    });

    // 监听应收账款确认事件
    this.contract.on('ReceivableConfirmed', async (id, confirmer, event) => {
      console.log('ReceivableConfirmed:', { id, confirmer });
      await this.syncReceivable(id);
    });

    // 监听应收账款转让事件
    this.contract.on('ReceivableTransferred', async (id, from, to, event) => {
      console.log('ReceivableTransferred:', { id, from, to });
      await this.syncReceivable(id);
    });

    console.log('开始监听合约事件...');
  }

  // 同步应收账款数据
  async syncReceivable(id) {
    const receivable = await this.contract.getReceivable(id);
    // 保存到数据库的逻辑
    // ... (在 syncService 中实现)
  }

  // 获取应收账款详情
  async getReceivable(id) {
    return await this.contract.getReceivable(id);
  }

  // 获取用户角色
  async getUserRole(address) {
    return await this.contract.getUserRole(address);
  }

  // 获取用户的应收账款列表
  async getReceivablesByOwner(address) {
    return await this.contract.getReceivablesByOwner(address);
  }

  // 获取用户发行的应收账款列表
  async getReceivablesByIssuer(address) {
    return await this.contract.getReceivablesByIssuer(address);
  }
}

module.exports = new Web3Service();
```

### 2. 应收账款控制器 (controllers/receivableController.js)

```javascript
const web3Service = require('../services/web3Service');
const ReceivableIndex = require('../models/ReceivableIndex');
const { ethers } = require('ethers');

class ReceivableController {
  // 获取应收账款列表
  async getReceivables(req, res, next) {
    try {
      const { owner, issuer, status, page = 1, limit = 10 } = req.query;
      
      const where = {};
      if (owner) where.owner_address = owner;
      if (issuer) where.issuer_address = issuer;
      if (status === 'confirmed') where.confirmed = true;
      if (status === 'financed') where.financed = true;
      if (status === 'settled') where.settled = true;

      const offset = (page - 1) * limit;

      const { count, rows } = await ReceivableIndex.findAndCountAll({
        where,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [['created_at', 'DESC']]
      });

      res.json({
        success: true,
        data: {
          total: count,
          page: parseInt(page),
          pageSize: parseInt(limit),
          items: rows
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // 获取应收账款详情
  async getReceivableDetail(req, res, next) {
    try {
      const { id } = req.params;

      // 从数据库获取
      const dbData = await ReceivableIndex.findOne({
        where: { receivable_id: id }
      });

      // 从链上获取最新数据
      const chainData = await web3Service.getReceivable(id);

      res.json({
        success: true,
        data: {
          db: dbData,
          chain: {
            id: chainData.id.toString(),
            issuer: chainData.issuer,
            owner: chainData.owner,
            supplier: chainData.supplier,
            amount: chainData.amount.toString(),
            createTime: new Date(Number(chainData.createTime) * 1000),
            dueTime: new Date(Number(chainData.dueTime) * 1000),
            confirmed: chainData.confirmed,
            financed: chainData.financed,
            settled: chainData.settled,
            description: chainData.description,
            contractNumber: chainData.contractNumber
          }
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // 创建应收账款（准备交易数据）
  async prepareCreateReceivable(req, res, next) {
    try {
      const { supplier, amount, dueTime, description, contractNumber } = req.body;

      // 参数校验
      if (!ethers.isAddress(supplier)) {
        return res.status(400).json({
          success: false,
          message: '无效的供应商地址'
        });
      }

      // 返回交易数据供前端签名
      const contractABI = require('../contracts/SupplyChainFinance.json');
      const iface = new ethers.Interface(contractABI.abi);
      
      const data = iface.encodeFunctionData('createReceivable', [
        supplier,
        ethers.parseEther(amount.toString()),
        Math.floor(new Date(dueTime).getTime() / 1000),
        description,
        contractNumber
      ]);

      res.json({
        success: true,
        data: {
          to: process.env.CONTRACT_ADDRESS,
          data: data
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // 确认交易已提交
  async confirmTransaction(req, res, next) {
    try {
      const { txHash, type, relatedId } = req.body;

      // 保存交易记录
      const TransactionHistory = require('../models/TransactionHistory');
      await TransactionHistory.create({
        tx_hash: txHash,
        from_address: req.body.from,
        to_address: process.env.CONTRACT_ADDRESS,
        tx_type: type,
        related_id: relatedId,
        status: 'pending'
      });

      // 等待交易确认
      const receipt = await web3Service.provider.waitForTransaction(txHash);

      if (receipt.status === 1) {
        // 更新交易状态
        await TransactionHistory.update(
          {
            status: 'success',
            block_number: receipt.blockNumber,
            gas_used: receipt.gasUsed.toString()
          },
          { where: { tx_hash: txHash } }
        );

        res.json({
          success: true,
          message: '交易确认成功',
          data: receipt
        });
      } else {
        await TransactionHistory.update(
          { status: 'failed' },
          { where: { tx_hash: txHash } }
        );

        res.status(400).json({
          success: false,
          message: '交易执行失败'
        });
      }
    } catch (error) {
      next(error);
    }
  }

  // 获取用户的应收账款统计
  async getUserStats(req, res, next) {
    try {
      const { address } = req.params;

      const stats = await ReceivableIndex.findAll({
        where: { owner_address: address },
        attributes: [
          [sequelize.fn('COUNT', sequelize.col('id')), 'total'],
          [sequelize.fn('SUM', sequelize.col('amount')), 'totalAmount'],
          [sequelize.fn('COUNT', sequelize.literal('CASE WHEN confirmed = 1 THEN 1 END')), 'confirmedCount'],
          [sequelize.fn('COUNT', sequelize.literal('CASE WHEN financed = 1 THEN 1 END')), 'financedCount']
        ]
      });

      res.json({
        success: true,
        data: stats[0]
      });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new ReceivableController();
```

### 3. 融资控制器 (controllers/financeController.js)

```javascript
const web3Service = require('../services/web3Service');
const FinanceAppIndex = require('../models/FinanceAppIndex');
const { ethers } = require('ethers');

class FinanceController {
  // 获取融资申请列表
  async getFinanceApplications(req, res, next) {
    try {
      const { applicant, financier, receivableId, status, page = 1, limit = 10 } = req.query;
      
      const where = {};
      if (applicant) where.applicant_address = applicant;
      if (financier) where.financier_address = financier;
      if (receivableId) where.receivable_id = receivableId;
      if (status === 'pending') where.processed = false;
      if (status === 'approved') {
        where.processed = true;
        where.approved = true;
      }
      if (status === 'rejected') {
        where.processed = true;
        where.approved = false;
      }

      const offset = (page - 1) * limit;

      const { count, rows } = await FinanceAppIndex.findAndCountAll({
        where,
        limit: parseInt(limit),
        offset: parseInt(offset),
        order: [['created_at', 'DESC']]
      });

      res.json({
        success: true,
        data: {
          total: count,
          page: parseInt(page),
          pageSize: parseInt(limit),
          items: rows
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // 准备融资申请交易
  async prepareApplyFinance(req, res, next) {
    try {
      const { receivableId, financier, financeAmount, interestRate } = req.body;

      const contractABI = require('../contracts/SupplyChainFinance.json');
      const iface = new ethers.Interface(contractABI.abi);
      
      const data = iface.encodeFunctionData('applyForFinance', [
        receivableId,
        financier,
        ethers.parseEther(financeAmount.toString()),
        interestRate
      ]);

      res.json({
        success: true,
        data: {
          to: process.env.CONTRACT_ADDRESS,
          data: data
        }
      });
    } catch (error) {
      next(error);
    }
  }

  // 准备审批融资交易
  async prepareApproveFinance(req, res, next) {
    try {
      const { applicationId, approve } = req.body;

      const contractABI = require('../contracts/SupplyChainFinance.json');
      const iface = new ethers.Interface(contractABI.abi);
      
      const data = iface.encodeFunctionData('approveFinanceApplication', [
        applicationId,
        approve
      ]);

      res.json({
        success: true,
        data: {
          to: process.env.CONTRACT_ADDRESS,
          data: data
        }
      });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new FinanceController();
```

### 4. 区块链同步服务 (services/syncService.js)

```javascript
const web3Service = require('./web3Service');
const ReceivableIndex = require('../models/ReceivableIndex');
const FinanceAppIndex = require('../models/FinanceAppIndex');
const SystemConfig = require('../models/SystemConfig');

class SyncService {
  constructor() {
    this.isSyncing = false;
  }

  // 启动同步服务
  async start() {
    console.log('启动区块链同步服务...');
    
    // 监听实时事件
    await web3Service.listenToEvents();

    // 定期同步历史数据
    setInterval(() => {
      this.syncHistoricalData();
    }, 60000); // 每分钟同步一次

    // 立即执行一次同步
    await this.syncHistoricalData();
  }

  // 同步历史数据
  async syncHistoricalData() {
    if (this.isSyncing) {
      console.log('同步进行中，跳过本次同步');
      return;
    }

    this.isSyncing = true;

    try {
      console.log('开始同步历史数据...');

      const receivableCounter = await web3Service.contract.receivableCounter();
      const totalReceivables = Number(receivableCounter);

      for (let i = 1; i <= totalReceivables; i++) {
        await this.syncReceivable(i);
      }

      console.log(`同步完成，共同步 ${totalReceivables} 条应收账款`);
    } catch (error) {
      console.error('同步失败:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  // 同步单个应收账款
  async syncReceivable(id) {
    try {
      const receivable = await web3Service.contract.getReceivable(id);

      if (receivable.id === 0n) {
        return; // 不存在的应收账款
      }

      await ReceivableIndex.upsert({
        receivable_id: Number(receivable.id),
        issuer_address: receivable.issuer,
        owner_address: receivable.owner,
        supplier_address: receivable.supplier,
        amount: receivable.amount.toString(),
        contract_number: receivable.contractNumber,
        description: receivable.description,
        create_time: new Date(Number(receivable.createTime) * 1000),
        due_time: new Date(Number(receivable.dueTime) * 1000),
        confirmed: receivable.confirmed,
        financed: receivable.financed,
        settled: receivable.settled
      });

      console.log(`同步应收账款 #${id} 成功`);
    } catch (error) {
      console.error(`同步应收账款 #${id} 失败:`, error);
    }
  }
}

module.exports = new SyncService();
```

---

## 🌐 API 接口设计

### 1. 用户相关

```
POST   /api/users/register          # 注册用户
GET    /api/users/:address          # 获取用户信息
PUT    /api/users/:address          # 更新用户信息
GET    /api/users/:address/role     # 获取用户角色
```

### 2. 应收账款相关

```
GET    /api/receivables             # 获取应收账款列表
GET    /api/receivables/:id         # 获取应收账款详情
POST   /api/receivables/prepare     # 准备创建应收账款交易
POST   /api/receivables/confirm-tx  # 确认交易已提交
GET    /api/receivables/stats/:address  # 获取用户统计
```

### 3. 融资相关

```
GET    /api/finance/applications    # 获取融资申请列表
GET    /api/finance/applications/:id # 获取融资申请详情
POST   /api/finance/prepare-apply   # 准备融资申请交易
POST   /api/finance/prepare-approve # 准备审批融资交易
```

### 4. 交易历史

```
GET    /api/transactions            # 获取交易历史
GET    /api/transactions/:hash      # 获取交易详情
```

---

## 📝 开发步骤

1. **初始化项目** (15分钟)
   ```bash
   mkdir backend && cd backend
   npm init -y
   npm install express sequelize mysql2 ethers dotenv cors morgan joi
   ```

2. **配置数据库** (20分钟)
   - 创建数据库
   - 运行 SQL 脚本
   - 配置 Sequelize 连接

3. **创建模型** (30分钟)
   - User, ReceivableIndex, FinanceAppIndex, TransactionHistory

4. **实现服务层** (1小时)
   - Web3Service
   - SyncService

5. **实现控制器** (1.5小时)
   - UserController
   - ReceivableController
   - FinanceController

6. **配置路由** (30分钟)

7. **测试接口** (30分钟)

**预计总时间：4-5小时**

---

## 🎁 交付物

- [x] 完整的 Node.js 后端项目
- [x] 数据库 SQL 脚本
- [x] API 文档
- [x] 环境配置示例文件
- [x] 启动脚本

---

## ⚠️ 注意事项

1. **环境变量管理**: 使用 .env 文件，不要提交敏感信息
2. **错误处理**: 统一的错误处理中间件
3. **日志记录**: 记录关键操作和错误信息
4. **参数校验**: 使用 Joi 进行严格的参数校验
5. **数据库索引**: 合理使用索引提升查询性能
6. **事务处理**: 关键操作使用数据库事务

---

## 🔗 相关资源

- Express.js: https://expressjs.com
- Sequelize: https://sequelize.org
- ethers.js: https://docs.ethers.org

